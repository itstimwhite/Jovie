name: AI Loop
on:
  schedule: [{ cron: '*/15 * * * *' }]
  workflow_dispatch:
  push:
    paths:
      - 'ops/**'
      - '.github/ISSUE_TEMPLATE/**'
      - '.github/copilot-instructions.md'
permissions:
  contents: write
  issues: write
  pull-requests: write
jobs:
  loop:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v5

      - name: Ensure labels exist
        uses: actions/github-script@v7
        with:
          script: |
            const wanted = ['ai-task','ai:in-progress','ai:ready-for-review','ai:needs-changes','ai:ready-to-merge','blocked'];
            const { data: existing } = await github.rest.issues.listLabelsForRepo({ owner: context.repo.owner, repo: context.repo.repo, per_page: 100 });
            const have = new Set(existing.map(l=>l.name));
            for (const name of wanted) {
              if (!have.has(name)) await github.rest.issues.createLabel({ owner: context.repo.owner, repo: context.repo.repo, name });
            }

      - name: Parse inbox → update plan (dedup by id)
        shell: bash
        run: |
          python3 - <<'PY'
          import re, pathlib
          inbox = pathlib.Path('ops/inbox.markdoc')
          plan  = pathlib.Path('ops/plan.md')
          if not inbox.exists():
              raise SystemExit(0)
          text = inbox.read_text()
          ideas = re.findall(r":::idea\n([\s\S]*?)\n:::", text)
          def kv(block, k):
              m = re.search(rf"^\s*{k}:\s*(.*)$", block, re.M)
              return (m.group(1).strip() if m else '')
          plan_txt = plan.read_text() if plan.exists() else "# Plan\n\n## Queue\n\n"
          for b in ideas:
              idv = kv(b,'id')
              title = kv(b,'title')
              labels = kv(b,'labels') or ''
              acc = re.findall(r"^\s*-\s*(.*)$", kv(b,'acceptance'), re.M)
              if idv and idv in plan_txt:
                  continue
              # append a task block
              lines = [
                "```task", f"id: {idv.replace('INBOX','JOV-PL') if idv else ''}", f"source: {idv}", f"title: {title}",
                f"labels: [{labels.strip('[]')}]", "priority: P2",
                "acceptance:"] + [f"  - {x}" for x in acc] + ["````\n".replace("````","```")]
              plan_txt += "\n" + "\n".join(lines)
          plan.write_text(plan_txt)
          PY
          git status --porcelain
          if ! git diff --quiet; then
            git config user.name "ai-loop"
            git config user.email "ai-loop@users.noreply.github.com"
            git add ops/plan.md
            git commit -m "chore(loop): sync inbox → plan"
            git push
          fi

      - name: Create/link issues from plan blocks
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const plan = fs.readFileSync('ops/plan.md','utf8');
            const blocks = [...plan.matchAll(/```task\n([\s\S]*?)```/g)].map(m=>m[1]);
            const get = (b,k)=>{ const m = b.match(new RegExp('^'+k+':\\s*(.*)$','m')); return m?m[1].trim():'' };
            let out = plan;
            for (const b of blocks) {
              if (/issue:\s*#\d+/i.test(b)) continue;
              const title = get(b,'title');
              const src   = get(b,'id');
              const labels = (get(b,'labels').replace(/[\[\]]/g,'').split(',').map(s=>s.trim()).filter(Boolean)).concat(['ai-task']);
              const body  = 'Source: '+get(b,'source')+'\n\nAcceptance:\n'+(b.match(/acceptance:[\s\S]*/)?.[0]||'');
              const issue = await github.rest.issues.create({ owner: context.repo.owner, repo: context.repo.repo, title, labels, body });
              const reBlock = new RegExp('```task\\n'+b.replace(/[.*+?^${}()|[\]\\]/g,'\\$&')+'```','m');
              out = out.replace(reBlock, '```task\n'+b+'\nissue: #'+issue.data.number+'\n```');
            }
            if (out !== plan) {
              const { execSync } = require('child_process');
              require('fs').writeFileSync('ops/plan.md', out);
              execSync('git config user.name "ai-loop"');
              execSync('git config user.email "ai-loop@users.noreply.github.com"');
              execSync('git add ops/plan.md');
              execSync('git commit -m "chore(loop): link issues to plan"');
              execSync('git push');
            }

      - name: Steward PRs (enable/disable auto-merge, relabel)
        uses: actions/github-script@v7
        with:
          script: |
            // List open PRs touched by AI
            const prs = await github.paginate(github.rest.pulls.list, { owner: context.repo.owner, repo: context.repo.repo, state: 'open', per_page: 100 });
            for (const pr of prs) {
              const { data: labels } = await github.rest.issues.listLabelsOnIssue({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number });
              const names = new Set(labels.map(l=>l.name));
              const ready = names.has('ai:ready-to-merge') && !names.has('blocked') && !pr.draft;
              const checks = await github.rest.checks.listForRef({ owner: context.repo.owner, repo: context.repo.repo, ref: pr.head.sha, per_page: 100 });
              const failing = checks.data.check_runs.some(c=>['failure','cancelled','timed_out','action_required'].includes(c.conclusion||''));
              if (ready && !failing) {
                // Enable auto-merge (requires repo setting enabled)
                try {
                  await github.graphql(`
                    mutation($id:ID!){ enablePullRequestAutoMerge(input:{ pullRequestId:$id, mergeMethod:SQUASH }){ clientMutationId } }
                  `, { id: pr.node_id });
                } catch(e) { /* ignore if already on */ }
              }
              if (failing) {
                // Remove auto-merge, add needs-changes, comment once
                try {
                  await github.graphql(`mutation($id:ID!){ disablePullRequestAutoMerge(input:{ pullRequestId:$id }){ clientMutationId } }`, { id: pr.node_id });
                } catch(e) {}
                if (!names.has('ai:needs-changes')) {
                  await github.rest.issues.addLabels({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, labels: ['ai:needs-changes'] });
                  await github.rest.issues.createComment({ owner: context.repo.owner, repo: context.repo.repo, issue_number: pr.number, body: 'Checks failing. Please address and relabel `ai:ready-for-review` when fixed.' });
                }
              }
            }
