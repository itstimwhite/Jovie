name: Smart Auto-Merge

# Consolidated auto-merge workflow for all PR types targeting preview branch
# Handles: Dependabot, Codegen, and regular PRs with intelligent branch updating

on:
  pull_request_target:
    types: [opened, edited, synchronize, labeled, unlabeled, ready_for_review]
    branches: [preview]
  check_suite:
    types: [completed]
  workflow_run:
    workflows: ['CI']
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  actions: read

concurrency:
  group: auto-merge-${{ github.event.pull_request.number || github.event.workflow_run.pull_requests[0].number }}
  cancel-in-progress: true

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    timeout-minutes: 10
    
    # Only run for preview branch PRs
    if: >
      (github.event.pull_request.base.ref == 'preview' || 
       (github.event.workflow_run.head_branch != 'preview' && 
        github.event.workflow_run.head_branch != 'production'))
    
    steps:
      - name: Get PR details
        id: get_pr
        uses: actions/github-script@v7
        with:
          script: |
            let pr;
            
            if (github.event_name === 'pull_request_target') {
              pr = github.event.pull_request;
            } else if (github.event_name === 'workflow_run') {
              // Find PR for completed workflow run
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                head: `${context.repo.owner}:${context.payload.workflow_run.head_branch}`,
                per_page: 100
              });
              pr = prs.data.find(p => p.head.sha === context.payload.workflow_run.head_sha);
            } else {
              // check_suite event - find PR by head SHA
              const prs = await github.rest.pulls.list({
                owner: context.repo.owner,
                repo: context.repo.repo,
                state: 'open',
                per_page: 100
              });
              pr = prs.data.find(p => p.head.sha === context.payload.check_suite.head_sha);
            }
            
            if (!pr) {
              core.info('No PR found for this event');
              return { skip: true };
            }
            
            if (pr.base.ref !== 'preview') {
              core.info('PR is not targeting preview branch, skipping');
              return { skip: true };
            }
            
            core.info(`Found PR #${pr.number}: ${pr.title}`);
            return {
              skip: false,
              number: pr.number,
              title: pr.title,
              author: pr.user.login,
              draft: pr.draft,
              mergeable_state: pr.mergeable_state,
              head_sha: pr.head.sha,
              head_ref: pr.head.ref,
              labels: pr.labels.map(l => l.name),
              auto_merge: pr.auto_merge !== null
            };

      - name: Check if PR should be auto-merged
        id: should_merge
        if: steps.get_pr.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = JSON.parse('${{ steps.get_pr.outputs.result }}');
            const labels = new Set(pr.labels);
            
            // Skip conditions
            const skipReasons = [];
            
            if (pr.draft) {
              skipReasons.push('PR is draft');
            }
            
            if (labels.has('blocked')) {
              skipReasons.push('blocked label');
            }
            
            if (labels.has('human-review')) {
              skipReasons.push('human-review label');
            }
            
            if (labels.has('no-auto-merge')) {
              skipReasons.push('no-auto-merge label');
            }
            
            if (labels.has('claude:needs-fixes')) {
              skipReasons.push('claude:needs-fixes label');
            }
            
            if (labels.has('needs-human')) {
              skipReasons.push('needs-human label');
            }
            
            if (skipReasons.length > 0) {
              core.info(`Skipping auto-merge: ${skipReasons.join(', ')}`);
              return { should_merge: false, reason: skipReasons.join(', ') };
            }
            
            // Determine PR type and eligibility
            let prType = 'regular';
            let eligible = false;
            
            if (pr.author === 'dependabot[bot]') {
              prType = 'dependabot';
              // For dependabot, check if it's patch/minor or security update
              eligible = true; // We'll validate update type in next step
            } else if (labels.has('codegen')) {
              prType = 'codegen';
              eligible = true;
            } else {
              prType = 'regular';
              // For regular PRs, only auto-merge if they have specific labels or conditions
              eligible = labels.has('auto-merge') || labels.has('dependencies');
            }
            
            core.info(`PR type: ${prType}, eligible: ${eligible}`);
            return { 
              should_merge: eligible, 
              pr_type: prType,
              reason: eligible ? `${prType} PR eligible for auto-merge` : `${prType} PR not eligible`
            };

      - name: Validate Dependabot update type
        id: validate_dependabot
        if: steps.should_merge.outputs.should_merge == 'true' && fromJSON(steps.should_merge.outputs.result).pr_type == 'dependabot'
        uses: dependabot/fetch-metadata@v2
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Check Dependabot eligibility
        id: dependabot_check
        if: steps.validate_dependabot.outcome == 'success'
        run: |
          update_type="${{ steps.validate_dependabot.outputs.update-type }}"
          dependency_type="${{ steps.validate_dependabot.outputs.dependency-type }}"
          
          # Allow security updates
          if [[ "$dependency_type" == "direct:security" ]]; then
            echo "allowed=true" >> $GITHUB_OUTPUT
            echo "reason=Security update" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          # Allow patch and minor updates
          if [[ "$update_type" =~ ^version-update:semver-(patch|minor)$ ]]; then
            echo "allowed=true" >> $GITHUB_OUTPUT
            echo "reason=Safe ${update_type#version-update:semver-} update" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "allowed=false" >> $GITHUB_OUTPUT
          echo "reason=Major version update requires human review" >> $GITHUB_OUTPUT

      - name: Wait for required CI checks
        id: wait_for_ci
        if: steps.should_merge.outputs.should_merge == 'true' && (steps.dependabot_check.outputs.allowed != 'false')
        uses: lewagon/wait-on-check-action@v1.3.3
        with:
          repo-token: ${{ secrets.GITHUB_TOKEN }}
          wait-interval: 15
          # Wait for all required checks from ruleset
          check-regexp: (?i)(pr.policy|typecheck|lint|build|unit.tests|e2e.tests)
          allowed-conclusions: success,skipped
          timeout-minutes: 30
          
      - name: Check if branch needs updating
        id: check_branch_status
        if: steps.wait_for_ci.outputs.status == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = JSON.parse('${{ steps.get_pr.outputs.result }}');
            
            try {
              // Get PR details to check mergeable state
              const { data: prData } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              core.info(`PR mergeable: ${prData.mergeable}, mergeable_state: ${prData.mergeable_state}`);
              
              // Check if branch is behind
              const needsUpdate = prData.mergeable_state === 'behind' || prData.mergeable_state === 'dirty';
              
              return {
                needs_update: needsUpdate,
                mergeable: prData.mergeable,
                mergeable_state: prData.mergeable_state
              };
            } catch (error) {
              core.warning(`Error checking branch status: ${error.message}`);
              return { needs_update: false, mergeable: null, mergeable_state: 'unknown' };
            }

      - name: Update branch if needed
        id: update_branch
        if: fromJSON(steps.check_branch_status.outputs.result).needs_update
        uses: actions/github-script@v7
        with:
          script: |
            const pr = JSON.parse('${{ steps.get_pr.outputs.result }}');
            
            try {
              core.info(`Updating branch for PR #${pr.number}`);
              
              await github.rest.pulls.updateBranch({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              core.info('Branch update requested successfully');
              
              // Wait a moment for update to process
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              return { updated: true };
            } catch (error) {
              core.warning(`Failed to update branch: ${error.message}`);
              return { updated: false, error: error.message };
            }

      - name: Mark PR ready for review
        id: mark_ready
        if: steps.wait_for_ci.outputs.status == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = JSON.parse('${{ steps.get_pr.outputs.result }}');
            
            if (pr.draft) {
              try {
                await github.graphql(
                  `mutation($id: ID!) { 
                    markPullRequestReadyForReview(input: { pullRequestId: $id }) { 
                      clientMutationId 
                    } 
                  }`,
                  { id: await github.rest.pulls.get({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: pr.number
                    }).then(r => r.data.node_id) }
                );
                core.info(`Marked PR #${pr.number} ready for review`);
                return { marked_ready: true };
              } catch (error) {
                core.warning(`Failed to mark PR ready: ${error.message}`);
                return { marked_ready: false, error: error.message };
              }
            }
            
            return { marked_ready: false, reason: 'PR already ready' };

      - name: Enable auto-merge
        id: enable_automerge
        if: steps.wait_for_ci.outputs.status == 'success'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = JSON.parse('${{ steps.get_pr.outputs.result }}');
            
            // If auto-merge is already enabled, skip
            if (pr.auto_merge) {
              core.info(`Auto-merge already enabled for PR #${pr.number}`);
              return { enabled: false, reason: 'Already enabled' };
            }
            
            try {
              // Get current PR node_id
              const { data: prData } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: pr.number
              });
              
              await github.graphql(
                `mutation($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {
                  enablePullRequestAutoMerge(input: { 
                    pullRequestId: $pullRequestId, 
                    mergeMethod: $mergeMethod 
                  }) {
                    pullRequest { number, autoMergeRequest { enabledAt } }
                  }
                }`,
                { 
                  pullRequestId: prData.node_id, 
                  mergeMethod: 'SQUASH' 
                }
              );
              
              core.info(`✅ Auto-merge enabled for PR #${pr.number} (squash method)`);
              return { enabled: true };
              
            } catch (error) {
              core.warning(`❌ Failed to enable auto-merge: ${error.message}`);
              return { enabled: false, error: error.message };
            }

      - name: Summary
        if: always() && steps.get_pr.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const pr = JSON.parse('${{ steps.get_pr.outputs.result }}');
            const shouldMerge = '${{ steps.should_merge.outputs.should_merge }}';
            const waitStatus = '${{ steps.wait_for_ci.outputs.status }}';
            const autoMergeEnabled = '${{ steps.enable_automerge.outputs.enabled }}';
            
            let summary = `## Auto-merge Summary for PR #${pr.number}\n\n`;
            
            if (shouldMerge !== 'true') {
              const reason = JSON.parse('${{ steps.should_merge.outputs.result || "{}" }}').reason || 'Unknown';
              summary += `❌ **Skipped**: ${reason}\n`;
            } else if (waitStatus !== 'success') {
              summary += `⏳ **Waiting**: CI checks still running or failed\n`;
            } else if (autoMergeEnabled === 'true') {
              summary += `✅ **Success**: Auto-merge enabled, PR will merge when all checks pass\n`;
            } else {
              summary += `⚠️ **Partial**: CI passed but auto-merge could not be enabled\n`;
            }
            
            summary += `\n**PR Type**: ${JSON.parse('${{ steps.should_merge.outputs.result || "{}" }}').pr_type || 'unknown'}`;
            summary += `\n**Labels**: ${pr.labels.join(', ') || 'none'}`;
            
            core.info(summary);