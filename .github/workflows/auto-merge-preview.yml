name: Auto-merge Preview PRs
on:
  workflow_run:
    workflows: ['CI']
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  merge:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const sha   = context.payload.workflow_run.head_sha;

            // find the PR for this CI run
            const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', per_page: 100 });
            const pr  = prs.find(p => p.head.sha === sha);
            if (!pr) return;

            // only target preview branch
            if (pr.base.ref !== 'preview') return;

            // skip if human said "don't"
            const labels = new Set(pr.labels.map(l => l.name));
            if (labels.has('blocked') || labels.has('human-review') || labels.has('no-auto-merge') || labels.has('claude:needs-fixes')) return;

            // drafts can't merge â€” mark ready
            if (pr.draft) {
              await github.graphql(
                `mutation($id:ID!){ markPullRequestReadyForReview(input:{ pullRequestId:$id }){ clientMutationId } }`,
                { id: pr.node_id }
              );
            }
            // Enable auto-merge (squash) so GitHub Merge Queue handles sequencing
            try {
              await github.graphql(
                `mutation($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {
                  enablePullRequestAutoMerge(input: { pullRequestId: $pullRequestId, mergeMethod: $mergeMethod }) {
                    pullRequest { number, autoMergeRequest { enabledAt } }
                  }
                }`,
                { pullRequestId: pr.node_id, mergeMethod: 'SQUASH' }
              );
            } catch (e) {
              core.warning(`Failed to enable auto-merge: ${e.message}`);
            }
