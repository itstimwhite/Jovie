name: Auto-merge Preview PRs
on:
  workflow_run:
    workflows: ['CI']
    types: [completed]

permissions:
  contents: write
  pull-requests: write

jobs:
  merge:
    if: ${{ github.event.workflow_run.conclusion == 'success' }}
    runs-on: ubuntu-latest
    steps:
      - uses: actions/github-script@v7
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;
            const sha   = context.payload.workflow_run.head_sha;

            // find the PR for this CI run
            const prs = await github.paginate(github.rest.pulls.list, { owner, repo, state: 'open', per_page: 100 });
            const pr  = prs.find(p => p.head.sha === sha);
            if (!pr) return;

            // only target preview branch
            if (pr.base.ref !== 'preview') return;

            // skip if human said "don't"
            const labels = new Set(pr.labels.map(l => l.name));
            if (labels.has('blocked') || labels.has('human-review') || labels.has('no-auto-merge')) return;

            // drafts can't merge â€” mark ready
            if (pr.draft) {
              await github.graphql(
                `mutation($id:ID!){ markPullRequestReadyForReview(input:{ pullRequestId:$id }){ clientMutationId } }`,
                { id: pr.node_id }
              );
            }

            // re-check checks + statuses
            const checks = await github.rest.checks.listForRef({ owner, repo, ref: pr.head.sha, per_page: 100 });
            const failing = checks.data.check_runs.some(c => c.status !== 'completed' || !['success','neutral','skipped'].includes(c.conclusion||''));
            const statuses = await github.rest.repos.getCombinedStatusForRef({ owner, repo, ref: pr.head.sha });
            const ok = !failing && statuses.data.state === 'success';
            if (!ok) return;

            // merge + cleanup branch when safe (same repo only)
            await github.rest.pulls.merge({ owner, repo, pull_number: pr.number, merge_method: 'squash' });
            try {
              if (pr.head.repo.full_name === `${owner}/${repo}`) {
                await github.rest.git.deleteRef({ owner, repo, ref: `heads/${pr.head.ref}` });
              }
            } catch (e) {}
